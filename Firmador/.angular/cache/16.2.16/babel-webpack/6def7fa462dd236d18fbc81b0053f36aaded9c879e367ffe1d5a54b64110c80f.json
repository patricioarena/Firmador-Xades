{"ast":null,"code":"import { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, Optional, EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';\nimport { WINDOW } from 'ngx-window-token';\nimport { Subject } from 'rxjs';\n\n/**\n * The following code is heavily copied from https://github.com/zenorocha/clipboard.js\n */\nlet ClipboardService = /*#__PURE__*/(() => {\n  class ClipboardService {\n    constructor(ngZone, document, window) {\n      this.ngZone = ngZone;\n      this.document = document;\n      this.window = window;\n      this.copySubject = new Subject();\n      this.copyResponse$ = this.copySubject.asObservable();\n      this.config = {};\n    }\n    configure(config) {\n      this.config = config;\n    }\n    copy(content) {\n      if (!this.isSupported || !content) {\n        return this.pushCopyResponse({\n          isSuccess: false,\n          content\n        });\n      }\n      const copyResult = this.copyFromContent(content);\n      if (copyResult) {\n        return this.pushCopyResponse({\n          content,\n          isSuccess: copyResult\n        });\n      }\n      return this.pushCopyResponse({\n        isSuccess: false,\n        content\n      });\n    }\n    get isSupported() {\n      return !!this.document.queryCommandSupported && !!this.document.queryCommandSupported('copy') && !!this.window;\n    }\n    isTargetValid(element) {\n      if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n        if (element.hasAttribute('disabled')) {\n          throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n        }\n        return true;\n      }\n      throw new Error('Target should be input or textarea');\n    }\n    /**\n     * Attempts to copy from an input `targetElm`\n     */\n    copyFromInputElement(targetElm, isFocus = true) {\n      try {\n        this.selectTarget(targetElm);\n        const re = this.copyText();\n        this.clearSelection(isFocus ? targetElm : undefined, this.window);\n        return re && this.isCopySuccessInIE11();\n      } catch (error) {\n        return false;\n      }\n    }\n    /**\n     * This is a hack for IE11 to return `true` even if copy fails.\n     */\n    isCopySuccessInIE11() {\n      const clipboardData = this.window['clipboardData'];\n      if (clipboardData && clipboardData.getData) {\n        if (!clipboardData.getData('Text')) {\n          return false;\n        }\n      }\n      return true;\n    }\n    /**\n     * Creates a fake textarea element, sets its value from `text` property,\n     * and makes a selection on it.\n     */\n    copyFromContent(content, container = this.document.body) {\n      // check if the temp textarea still belongs to the current container.\n      // In case we have multiple places using ngx-clipboard, one is in a modal using container but the other one is not.\n      if (this.tempTextArea && !container.contains(this.tempTextArea)) {\n        this.destroy(this.tempTextArea.parentElement || undefined);\n      }\n      if (!this.tempTextArea) {\n        this.tempTextArea = this.createTempTextArea(this.document, this.window);\n        try {\n          container.appendChild(this.tempTextArea);\n        } catch (error) {\n          throw new Error('Container should be a Dom element');\n        }\n      }\n      this.tempTextArea.value = content;\n      const toReturn = this.copyFromInputElement(this.tempTextArea, false);\n      if (this.config.cleanUpAfterCopy) {\n        this.destroy(this.tempTextArea.parentElement || undefined);\n      }\n      return toReturn;\n    }\n    /**\n     * Remove temporary textarea if any exists.\n     */\n    destroy(container = this.document.body) {\n      if (this.tempTextArea) {\n        container.removeChild(this.tempTextArea);\n        // removeChild doesn't remove the reference from memory\n        this.tempTextArea = undefined;\n      }\n    }\n    /**\n     * Select the target html input element.\n     */\n    selectTarget(inputElement) {\n      inputElement.select();\n      inputElement.setSelectionRange(0, inputElement.value.length);\n      return inputElement.value.length;\n    }\n    copyText() {\n      return this.document.execCommand('copy');\n    }\n    /**\n     * Moves focus away from `target` and back to the trigger, removes current selection.\n     */\n    clearSelection(inputElement, window) {\n      inputElement && inputElement.focus();\n      window.getSelection()?.removeAllRanges();\n    }\n    /**\n     * Creates a fake textarea for copy command.\n     */\n    createTempTextArea(doc, window) {\n      const isRTL = doc.documentElement.getAttribute('dir') === 'rtl';\n      let ta;\n      ta = doc.createElement('textarea');\n      // Prevent zooming on iOS\n      ta.style.fontSize = '12pt';\n      // Reset box model\n      ta.style.border = '0';\n      ta.style.padding = '0';\n      ta.style.margin = '0';\n      // Move element out of screen horizontally\n      ta.style.position = 'absolute';\n      ta.style[isRTL ? 'right' : 'left'] = '-9999px';\n      // Move element to the same position vertically\n      const yPosition = window.pageYOffset || doc.documentElement.scrollTop;\n      ta.style.top = yPosition + 'px';\n      ta.setAttribute('readonly', '');\n      return ta;\n    }\n    /**\n     * Pushes copy operation response to copySubject, to provide global access\n     * to the response.\n     */\n    pushCopyResponse(response) {\n      if (this.copySubject.observers.length > 0) {\n        this.ngZone.run(() => {\n          this.copySubject.next(response);\n        });\n      }\n    }\n    /**\n     * @deprecated use pushCopyResponse instead.\n     */\n    pushCopyReponse(response) {\n      this.pushCopyResponse(response);\n    }\n  }\n  ClipboardService.ɵfac = function ClipboardService_Factory(t) {\n    return new (t || ClipboardService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(WINDOW, 8));\n  };\n  ClipboardService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ClipboardService,\n    factory: ClipboardService.ɵfac,\n    providedIn: 'root'\n  });\n  return ClipboardService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ClipboardDirective = /*#__PURE__*/(() => {\n  class ClipboardDirective {\n    constructor(ngZone, host, renderer, clipboardSrv) {\n      this.ngZone = ngZone;\n      this.host = host;\n      this.renderer = renderer;\n      this.clipboardSrv = clipboardSrv;\n      this.cbOnSuccess = new EventEmitter();\n      this.cbOnError = new EventEmitter();\n      this.onClick = event => {\n        if (!this.clipboardSrv.isSupported) {\n          this.handleResult(false, undefined, event);\n        } else if (this.targetElm && this.clipboardSrv.isTargetValid(this.targetElm)) {\n          this.handleResult(this.clipboardSrv.copyFromInputElement(this.targetElm), this.targetElm.value, event);\n        } else if (this.cbContent) {\n          this.handleResult(this.clipboardSrv.copyFromContent(this.cbContent, this.container), this.cbContent, event);\n        }\n      };\n    }\n    // eslint-disable-next-line no-empty, @typescript-eslint/no-empty-function\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        // By default each host listener schedules change detection and also wrapped\n        // into additional function that calls `markForCheck()`. We're listening the `click`\n        // event in the context of the root zone to avoid running unnecessary change detections,\n        // since this directive doesn't do anything template-related (e.g. updates template variables).\n        this.clickListener = this.renderer.listen(this.host.nativeElement, 'click', this.onClick);\n      });\n    }\n    ngOnDestroy() {\n      if (this.clickListener) {\n        this.clickListener();\n      }\n      this.clipboardSrv.destroy(this.container);\n    }\n    /**\n     * Fires an event based on the copy operation result.\n     * @param succeeded\n     */\n    handleResult(succeeded, copiedContent, event) {\n      let response = {\n        isSuccess: succeeded,\n        content: copiedContent,\n        successMessage: this.cbSuccessMsg,\n        event\n      };\n      if (succeeded) {\n        if (this.cbOnSuccess.observed) {\n          this.ngZone.run(() => {\n            this.cbOnSuccess.emit(response);\n          });\n        }\n      } else {\n        if (this.cbOnError.observed) {\n          this.ngZone.run(() => {\n            this.cbOnError.emit(response);\n          });\n        }\n      }\n      this.clipboardSrv.pushCopyResponse(response);\n    }\n  }\n  ClipboardDirective.ɵfac = function ClipboardDirective_Factory(t) {\n    return new (t || ClipboardDirective)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(ClipboardService));\n  };\n  ClipboardDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ClipboardDirective,\n    selectors: [[\"\", \"ngxClipboard\", \"\"]],\n    inputs: {\n      targetElm: [\"ngxClipboard\", \"targetElm\"],\n      container: \"container\",\n      cbContent: \"cbContent\",\n      cbSuccessMsg: \"cbSuccessMsg\"\n    },\n    outputs: {\n      cbOnSuccess: \"cbOnSuccess\",\n      cbOnError: \"cbOnError\"\n    }\n  });\n  return ClipboardDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ClipboardIfSupportedDirective = /*#__PURE__*/(() => {\n  class ClipboardIfSupportedDirective {\n    constructor(_clipboardService, _viewContainerRef, _templateRef) {\n      this._clipboardService = _clipboardService;\n      this._viewContainerRef = _viewContainerRef;\n      this._templateRef = _templateRef;\n    }\n    ngOnInit() {\n      if (this._clipboardService.isSupported) {\n        this._viewContainerRef.createEmbeddedView(this._templateRef);\n      }\n    }\n  }\n  ClipboardIfSupportedDirective.ɵfac = function ClipboardIfSupportedDirective_Factory(t) {\n    return new (t || ClipboardIfSupportedDirective)(i0.ɵɵdirectiveInject(ClipboardService), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n  ClipboardIfSupportedDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ClipboardIfSupportedDirective,\n    selectors: [[\"\", \"ngxClipboardIfSupported\", \"\"]]\n  });\n  return ClipboardIfSupportedDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ClipboardModule = /*#__PURE__*/(() => {\n  class ClipboardModule {}\n  ClipboardModule.ɵfac = function ClipboardModule_Factory(t) {\n    return new (t || ClipboardModule)();\n  };\n  ClipboardModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ClipboardModule\n  });\n  ClipboardModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return ClipboardModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of ngx-clipboard\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ClipboardDirective, ClipboardIfSupportedDirective, ClipboardModule, ClipboardService };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}